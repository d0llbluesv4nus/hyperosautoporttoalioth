name: Port ROM for Poco F3 (Alioth)

on:
  workflow_dispatch:
    inputs:
      base_url:
        description: 'Ссылка на базовую прошивку (Alioth - Fastboot/Recovery)'
        required: true
      port_url:
        description: 'Ссылка на порт-прошивку (Donor - Recovery/Fastboot)'
        required: true
      rom_name:
        description: 'Имя выходного файла (без расширения)'
        default: 'HyperOS_Port_Alioth'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      # 1. Клонирование репозитория
      - name: Checkout Repository
        uses: actions/checkout@v4

      # 2. Очистка места (КРИТИЧНО ВАЖНО для Android портов)
      - name: Cleanup Disk Space
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      # 3. Установка зависимостей и инструментов
      - name: Install Tools & Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y git aria2 python3 python3-pip zip unzip p7zip-full tar zstd
          
          # Установка EROFS Utils (для HyperOS)
          sudo apt-get install -y erofs-utils
          
          # Создаем папку для бинарников
          mkdir -p bin
          
          # --- Payload Dumper (для Recovery ROM) ---
          wget https://github.com/ssut/payload-dumper-go/releases/download/1.2.2/payload-dumper-go_1.2.2_linux_amd64.tar.gz
          tar -xvf payload-dumper-go_1.2.2_linux_amd64.tar.gz
          mv payload-dumper-go bin/
          
          # --- Android OTA Tools (lpunpack, lpmake, img2sdat) ---
          # Скачиваем готовые бинарники, так как компилировать долго
          wget https://github.com/toraidl/android_tools/raw/main/linux/lpunpack -O bin/lpunpack
          wget https://github.com/toraidl/android_tools/raw/main/linux/lpmake -O bin/lpmake
          wget https://github.com/toraidl/android_tools/raw/main/linux/simg2img -O bin/simg2img
          
          # Даем права на выполнение
          chmod +x bin/*
          
          # Добавляем bin в PATH для текущей сессии
          echo "$(pwd)/bin" >> $GITHUB_PATH

      # 4. Скачивание прошивок
      - name: Download ROMs
        run: |
          mkdir -p input/base input/port
          
          echo ">>> Downloading Base ROM..."
          aria2c -x16 -s16 -d input/base -o base_rom "${{ inputs.base_url }}"
          
          echo ">>> Downloading Port ROM..."
          aria2c -x16 -s16 -d input/port -o port_rom "${{ inputs.port_url }}"

      # 5. Распаковка (Универсальная логика)
      - name: Extract ROMs
        run: |
          mkdir -p workspace/base workspace/port
          
          # --- ФУНКЦИЯ РАСПАКОВКИ ---
          extract_rom() {
            type=$1   # base или port
            input_file="input/$type/${type}_rom"
            out_dir="workspace/$type"
            temp_dir="input/$type/temp"
            mkdir -p "$temp_dir"
            
            echo ">>> Extracting $type..."
            
            # 1. Распаковка архива (Zip/Tgz)
            if file "$input_file" | grep -q "Zip archive"; then
                unzip "$input_file" -d "$temp_dir"
            elif file "$input_file" | grep -q "gzip compressed"; then
                tar -xzvf "$input_file" -C "$temp_dir"
            else
                echo "Unknown format for $type"
                exit 1
            fi
            
            # 2. Поиск payload.bin (Recovery ROM)
            if [ -f "$temp_dir/payload.bin" ]; then
                echo "Found payload.bin, dumping..."
                payload-dumper-go -o "$out_dir" "$temp_dir/payload.bin"
            
            # 3. Поиск super.img (Fastboot ROM)
            elif [ -n "$(find "$temp_dir" -name 'super.img')" ]; then
                echo "Found super.img, unpacking..."
                find "$temp_dir" -name 'super.img' -exec lpunpack {} "$out_dir" \;
            
            # 4. Поиск отдельных images (Sparse Fastboot)
            elif [ -n "$(find "$temp_dir" -name 'system.img')" ]; then
                echo "Found raw images..."
                find "$temp_dir" -name '*.img' -exec mv {} "$out_dir/" \;
            else
                # Пробуем найти super.img внутри вложенных папок/архивов (для tgz)
                 find "$temp_dir" -name 'super.img' -exec lpunpack {} "$out_dir" \;
            fi
            
            # Очистка временных файлов для экономии места
            rm -rf "$temp_dir"
            rm -f "$input_file"
          }
          
          # Запуск функции для обоих образов
          extract_rom "base"
          extract_rom "port"

      # 6. Запуск скрипта портирования
      - name: Run Porting Script
        run: |
          if [ ! -f port_script.sh ]; then
            echo "Error: port_script.sh not found!"
            exit 1
          fi
          
          chmod +x port_script.sh
          
          # Передаем пути и запускаем под sudo (нужно для mount EROFS)
          # Используем $(pwd) чтобы передать абсолютные пути
          sudo env PATH=$PATH:$(pwd)/bin ./port_script.sh $(pwd)/workspace/base $(pwd)/workspace/port

      # 7. Подготовка выходного файла
      - name: Compress & Upload
        run: |
          mkdir -p out
          
          # Если скрипт создал super.img (идеальный вариант)
          if [ -f "working/super.img" ]; then
            mv working/super.img out/
          # Если скрипт создал отдельные образы
          elif [ -d "working/out" ]; then
            mv working/out/*.img out/
          else
             echo "No output images found!"
             exit 1
          fi
          
          # Добавляем boot.img из базы (нужен для загрузки)
          # Ищем boot.img в workspace/base
          find workspace/base -name "boot.img" -exec cp {} out/ \;
          
          # Архивируем
          cd out
          zip -r9 ../${{ inputs.rom_name }}.zip .
          cd ..
          
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.rom_name }}
          path: ${{ inputs.rom_name }}.zip
